diff --git a/contracts/rollup/IRollup.sol b/contracts/rollup/IRollup.sol
index cb3236d..c786bd3 100644
--- a/contracts/rollup/IRollup.sol
+++ b/contracts/rollup/IRollup.sol
@@ -25,8 +25,8 @@ interface IRollup {
 	/// @notice Error thrown when the specified block number is greater than the latest block number
 	error BlockNumberOutOfRange();
 
-	/// @notice Error thrown when the block poster is not a valid block builder
-	error InvalidBlockBuilder();
+	/// @notice Error thrown when the fee for the rate limiter is insufficient
+	error InsufficientPenaltyFee();
 
 	/// @notice Event emitted when deposits bridged from the liquidity contract are processed
 	/// @param lastProcessedDepositId The ID of the last processed deposit
@@ -64,7 +64,7 @@ interface IRollup {
 	event AccountIdsPosted(uint256 indexed blockNumber, bytes accountIds);
 
 	/// @notice Posts a registration block (for all senders' first transactions, specified by public keys)
-	/// @dev The function caller must have staked in the block builder registry beforehand
+	/// @dev msg.value must be greater than or equal to the penalty fee of the rate limiter
 	/// @param txTreeRoot The root of the transaction tree
 	/// @param senderFlags Flags indicating whether senders' signatures are included in the aggregated signature
 	/// @param aggregatedPublicKey The aggregated public key
@@ -78,10 +78,10 @@ interface IRollup {
 		bytes32[4] calldata aggregatedSignature,
 		bytes32[4] calldata messagePoint,
 		uint256[] calldata senderPublicKeys
-	) external;
+	) external payable;
 
 	/// @notice Posts a non-registration block (for all senders' subsequent transactions, specified by account IDs)
-	/// @dev The function caller must have staked in the block builder registry beforehand
+	/// @dev msg.value must be greater than or equal to the penalty fee of the rate limiter
 	/// @param txTreeRoot The root of the transaction tree
 	/// @param senderFlags Sender flags
 	/// @param aggregatedPublicKey The aggregated public key
@@ -97,7 +97,12 @@ interface IRollup {
 		bytes32[4] calldata messagePoint,
 		bytes32 publicKeysHash,
 		bytes calldata senderAccountIds
-	) external;
+	) external payable;
+
+	/// @notice Withdraws the penalty fee from the Rollup contract
+	/// @param to The address to which the penalty fee is transferred
+	/// @dev Only the owner can call this function
+	function withdrawPenaltyFee(address to) external;
 
 	/// @notice Update the deposit tree branch and root
 	/// @dev Only Liquidity contract can call this function via Scroll Messenger
diff --git a/contracts/rollup/Rollup.sol b/contracts/rollup/Rollup.sol
index 9f69318..e1d0b74 100644
--- a/contracts/rollup/Rollup.sol
+++ b/contracts/rollup/Rollup.sol
@@ -11,10 +11,12 @@ import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/Own
 import {DepositTreeLib} from "./lib/DepositTreeLib.sol";
 import {BlockHashLib} from "./lib/BlockHashLib.sol";
 import {PairingLib} from "./lib/PairingLib.sol";
+import {RateLimiterLib} from "./lib/RateLimiterLib.sol";
 
 contract Rollup is IRollup, OwnableUpgradeable, UUPSUpgradeable {
 	using BlockHashLib for bytes32[];
 	using DepositTreeLib for DepositTreeLib.DepositTree;
+	using RateLimiterLib for RateLimiterLib.RateLimitState;
 
 	uint256 private constant NUM_SENDERS_IN_BLOCK = 128;
 	uint256 private constant FULL_ACCOUNT_IDS_BYTES = NUM_SENDERS_IN_BLOCK * 5;
@@ -27,6 +29,7 @@ contract Rollup is IRollup, OwnableUpgradeable, UUPSUpgradeable {
 	IL2ScrollMessenger private l2ScrollMessenger;
 	IContribution private contribution;
 	DepositTreeLib.DepositTree private depositTree;
+	RateLimiterLib.RateLimitState private rateLimitState;
 	bytes32 public depositTreeRoot;
 
 	modifier onlyLiquidityContract() {
@@ -70,7 +73,7 @@ contract Rollup is IRollup, OwnableUpgradeable, UUPSUpgradeable {
 		bytes32[4] calldata aggregatedSignature,
 		bytes32[4] calldata messagePoint,
 		uint256[] calldata senderPublicKeys
-	) external {
+	) external payable {
 		uint256 length = senderPublicKeys.length;
 		if (length > NUM_SENDERS_IN_BLOCK) {
 			revert TooManySenderPublicKeys();
@@ -107,7 +110,7 @@ contract Rollup is IRollup, OwnableUpgradeable, UUPSUpgradeable {
 		bytes32[4] calldata messagePoint,
 		bytes32 publicKeysHash,
 		bytes calldata senderAccountIds
-	) external {
+	) external payable {
 		uint256 length = senderAccountIds.length;
 		if (length > FULL_ACCOUNT_IDS_BYTES) {
 			revert TooManyAccountIds();
@@ -161,6 +164,15 @@ contract Rollup is IRollup, OwnableUpgradeable, UUPSUpgradeable {
 		bytes32[4] calldata aggregatedSignature,
 		bytes32[4] calldata messagePoint
 	) private {
+		uint256 penalty = rateLimitState.update();
+		if (penalty > msg.value) {
+			revert InsufficientPenaltyFee();
+		}
+		// refund the excess fee
+		if (msg.value > 0) {
+			payable(_msgSender()).transfer(msg.value - penalty);
+		}
+
 		bool success = PairingLib.pairing(
 			aggregatedPublicKey,
 			aggregatedSignature,
@@ -202,6 +214,10 @@ contract Rollup is IRollup, OwnableUpgradeable, UUPSUpgradeable {
 		);
 	}
 
+	function withdrawPenaltyFee(address to) external onlyOwner {
+		payable(to).transfer(address(this).balance);
+	}
+
 	function getLatestBlockNumber() external view returns (uint32) {
 		return blockHashes.getBlockNumber() - 1;
 	}
diff --git a/contracts/rollup/lib/RateLimiterLib.sol b/contracts/rollup/lib/RateLimiterLib.sol
index b6a85f8..61e8639 100644
--- a/contracts/rollup/lib/RateLimiterLib.sol
+++ b/contracts/rollup/lib/RateLimiterLib.sol
@@ -19,7 +19,7 @@ library RateLimiterLib {
 
 	/// @notice Updates the rate limit state and calculates penalty
 	/// @param state The current state of the rate limiter
-	/// @return uint256 The calculated penalty (if any)
+	/// @return uint256 The calculated penalty
 	function update(RateLimitState storage state) internal returns (uint256) {
 		uint256 currentTime = block.timestamp;
 
@@ -35,11 +35,10 @@ library RateLimiterLib {
 		// Formula: emaInterval = alpha * interval + (1 - alpha) * emaInterval
 		SD59x18 alpha = sd(ALPHA);
 		SD59x18 interval = convert(int256(currentTime - state.lastCallTime));
+
 		state.emaInterval = alpha.mul(interval).add(
 			(convert(1).sub(alpha)).mul(state.emaInterval)
 		);
-
-		// Update last call time
 		state.lastCallTime = currentTime;
 
 		// Check if the EMA is less than the target interval
diff --git a/test/rollup/rollup.test.ts b/test/rollup/rollup.test.ts
index cceb245..2ccb45d 100644
--- a/test/rollup/rollup.test.ts
+++ b/test/rollup/rollup.test.ts
@@ -106,16 +106,15 @@ describe('Rollup', () => {
 	): Promise<void> => {
 		await blockBuilderRegistry.setResult(true)
 		const inputs = generateValidInputs()
-		await rollup
-			.connect(signer)
-			.postRegistrationBlock(
-				inputs.txTreeRoot,
-				inputs.senderFlags,
-				inputs.aggregatedPublicKey,
-				inputs.aggregatedSignature,
-				inputs.messagePoint,
-				inputs.senderPublicKeys,
-			)
+		await rollup.connect(signer).postRegistrationBlock(
+			inputs.txTreeRoot,
+			inputs.senderFlags,
+			inputs.aggregatedPublicKey,
+			inputs.aggregatedSignature,
+			inputs.messagePoint,
+			inputs.senderPublicKeys,
+			{ value: ethers.parseEther('1') }, // pay enough penalty
+		)
 	}
 	describe('initialize', () => {
 		describe('success', () => {
diff --git a/utils/rollup.ts b/utils/rollup.ts
index 2c9d6e8..05d4a3e 100644
--- a/utils/rollup.ts
+++ b/utils/rollup.ts
@@ -1,6 +1,7 @@
 import { Rollup } from '../typechain-types'
 import * as fs from 'fs'
 import type { ContractTransactionResponse } from 'ethers'
+import { ethers } from 'hardhat'
 
 export function loadFullBlocks(): FullBlock[] {
 	let fullBlocks = []
@@ -33,6 +34,7 @@ export async function postBlock(
 			fullBlock.signature.aggSignature,
 			fullBlock.signature.messagePoint,
 			fullBlock.pubkeys,
+			{ value: ethers.parseEther('1') },
 		)
 		return tx
 	} else {
@@ -47,6 +49,7 @@ export async function postBlock(
 			fullBlock.signature.messagePoint,
 			fullBlock.signature.pubkeyHash,
 			fullBlock.accountIds,
+			{ value: ethers.parseEther('1') },
 		)
 		return tx
 	}
